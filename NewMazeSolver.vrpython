{"mode":"Text","hardwareTarget":"brain","textContent":"global cellSize\nglobal mazeInfo\n#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# just settiing the speed of the robot to the maximum value\ndrivetrain.set_drive_velocity(100, PERCENT)\ndrivetrain.set_turn_velocity(100, PERCENT)\n# I found documentation that the maze is 2000mm by 2000mm, the maze is 8 by 8 cells,\n# meaning that each cell is 250mm by 250mm\ncellSize = 250\n# I will be storing the maze info as a dictionary with the key being the coodinates in relation to the origin,\n# this will mean that the robot should be able to work for any size maze. The robot can also quickly check if\n# it has been to a cell before by checking if it exists in the dictionary\nmazeInfo = {}\n# this is just a variable to track where the robot is in relation to the start of the maze.\ncurrentPosition = [0, 0]\nendPosition = []\n\n# this class will store info about tbe cell\n# it stores wether a direction has a wall and if a cell is the end cell\nclass CellInfo:\n    north = False\n    east = False\n    south = False\n    west = False\n    isEnd = False\n\nfullySearched = False\n\n# this method assumes that the entrence is at the bottom of the maze\n# and that the end of the maze is at the top because the robot can leave the maze at these places\ndef searchCell():\n    posistionString = f\"{currentPosision[0]}, currentPosition[1]\"\n    mazeInfo[posistionString] = CellInfo()\n    isEnd = down_eye.detect(RED)\n    if isEnd:\n        endPosition = [currentPosition[0], currentPosition[1]]\n        mazeInfo[posistionString].north = True\n\n    if currentPosition[0] == 0 and currentPosition[1] == 0:\n        mazeInfo[posistionString].south = True\n\n    if mazeInfo[posistionString].north == False:\n        drivetrain.turn_to_heading(0, DEGREES)\n        mazeInfo[posistionString].north = front_eye.detect(RED)\n\n    if mazeInfo[posistionString].east == False:\n        drivetrain.turn_to_heading(90, DEGREES)\n        mazeInfo[posistionString].east = front_eye.detect(RED)\n\n    if mazeInfo[posistionString].south == False:\n        drivetrain.turn_to_heading(180, DEGREES)\n        mazeInfo[posistionString].south = front_eye.detect(RED)\n\n    if mazeInfo[posistionString].west == False:\n        drivetrain.turn_to_heading(270, DEGREES)\n        mazeInfo[posistionString].west = front_eye.detect(RED)\n\n# just a method to move the robot\ndef moveRobot(direction):\n    if direction == \"n\":\n        drivetrain.turn_to_heading(0, DEGREES)\n    if direction == \"e\":\n        drivetrain.turn_to_heading(90, DEGREES)\n    if direction == \"s\":\n        drivetrain.turn_to_heading(180, DEGREES)\n    if direction == \"w\":\n        drivetrain.turn_to_heading(270, DEGREES)\n    if front_eye.detect(RED) == False:\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n\ndef when_started1():\n    \n    pass\n\nvr_thread(when_started1)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}