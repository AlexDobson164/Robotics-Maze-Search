{"mode":"Text","hardwareTarget":"brain","textContent":"global cellSize\nglobal mazeInfo\nglobal currentPosition\nglobal movementStack\nglobal endPosition\n#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# just settiing the speed of the robot to the maximum value\ndrivetrain.set_drive_velocity(100, PERCENT)\ndrivetrain.set_turn_velocity(100, PERCENT)\n\n# I found documentation that the maze is 2000mm by 2000mm, the maze is 8 by 8 cells,\n# meaning that each cell is 250mm by 250mm\ncellSize = 250\n\n# I will be storing the maze info as a dictionary with the key being the coodinates in relation to the origin,\n# this will mean that the robot should be able to work for any size maze. The robot can also quickly check if\n# it has been to a cell before by checking if it exists in the dictionary\nmazeInfo = {}\n\n# this is just a variable to track where the robot is in relation to the start of the maze.\ncurrentPosition = [0, 0]\nendPosition = []\n\n# a stack which will store the movements the robot has made, once it has reached a dead end, it can then pop off \n# of this stack until it reaches a point that it can start exploring the maze again\nmovementStack = []\n\n# this class will store info about tbe cell\n# it stores wether a direction has a wall and if a cell is the end cell\nclass CellInfo:\n    north = False\n    east = False\n    south = False\n    west = False\n    isEnd = False\n\nfullySearched = False\n\n# this method assumes that the entrence is at the bottom of the maze\n# and that the end of the maze is at the top because the robot can leave the maze at these places\ndef SearchCell():\n    global endPosition\n    global mazeInfo\n    posistionString = f\"{currentPosition[0]}, {currentPosition[1]}\"\n    mazeInfo[posistionString] = CellInfo()\n    isEnd = down_eye.detect(RED)\n\n    if isEnd:\n        endPosition = [currentPosition[0], currentPosition[1]]\n        mazeInfo[posistionString].north = True\n\n    if currentPosition[0] == 0 and currentPosition[1] == 0:\n        mazeInfo[posistionString].south = True\n    \n    # this bit of code gets the last move the robot made so that it wont look behind its self,\n    # i initally set lastMove as \"n\" because it simulates the robot entering the maze.\n    # this also stop a null error from occuring if the stack is empty.\n    lastMove = \"n\"\n    if len(movementStack) != 0:\n        lastMove = movementStack[len(movementStack) - 1]\n\n    # each direction has 2 checks. the first check makes sure that the direction hasnt been looked at before, \n    # the second check makes sure that the robot doesnt look in the direction that it just came from\n    if not mazeInfo[posistionString].north and lastMove != \"s\":\n        drivetrain.turn_to_heading(0, DEGREES)\n        mazeInfo[posistionString].north = front_eye.detect(RED)\n\n    if not mazeInfo[posistionString].east and lastMove != \"w\":\n        drivetrain.turn_to_heading(90, DEGREES)\n        mazeInfo[posistionString].east = front_eye.detect(RED)\n\n    if not mazeInfo[posistionString].south and lastMove != \"n\":\n        drivetrain.turn_to_heading(180, DEGREES)\n        mazeInfo[posistionString].south = front_eye.detect(RED)\n\n    if not mazeInfo[posistionString].west and lastMove != \"e\":\n        drivetrain.turn_to_heading(270, DEGREES)\n        mazeInfo[posistionString].west = front_eye.detect(RED)\n\n# just a method to move the robot\ndef MoveRobot(direction):\n    movementStack.append(direction)\n    if direction == \"n\":\n        drivetrain.turn_to_heading(0, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition[1] += 1\n    if direction == \"e\":\n        drivetrain.turn_to_heading(90, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition[0] += 1\n    if direction == \"s\":\n        drivetrain.turn_to_heading(180, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition[1] -= 1\n    if direction == \"w\":\n        drivetrain.turn_to_heading(270, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition[0] -= 1\n\n# this method will make the robot backtrack by looking at the top of the movementStack and doing the oposite and\n# then popping the top of the stack off.\ndef BackTrack():\n    topOfStack = movementStack.pop()\n    if topOfStack == \"n\":\n        MoveRobot(\"s\")\n    if topOfStack == \"e\":\n        MoveRobot(\"w\")\n    if topOfStack == \"s\":\n        MoveRobot(\"n\")\n    if topOfStack == \"w\":\n        MoveRobot(\"e\")\n    # i need to pop the top of the stack off again because the moveRobot method adds the last movement to the stack\n    # and i did not feel like it was worth it to make a new movement method without this functionality\n    movementStack.pop()\n\n# this is the method that will handle all of the logic for when the robot is mapping out the maze\ndef SearchMaze():\n    searching = True\n    while searching:\n        searchedCells = list(mazeInfo.keys())\n        if not f\"{currentPosition[0]}, {currentPosition[1]}\" in searchedCells:\n            SearchCell()\n        # bot decides which way to go next by checking which cells around it it has not gone yet\n        # the bot will check up, then left, then down and finally right\n        currentCellInfo = mazeInfo[f\"{currentPosition[0]}, {currentPosition[1]}\"]\n        if not f\"{currentPosition[0]}, {currentPosition[1] + 1}\" in searchedCells and currentCellInfo.north == False:\n            MoveRobot(\"n\")\n        elif not f\"{currentPosition[0] + 1}, {currentPosition[1]}\" in searchedCells and currentCellInfo.east == False:\n            MoveRobot(\"e\")\n        elif not f\"{currentPosition[0]}, {currentPosition[1] - 1}\" in searchedCells and currentCellInfo.south == False:\n            MoveRobot(\"s\")\n        elif not f\"{currentPosition[0] - 1}, {currentPosition[1]}\" in searchedCells and currentCellInfo.west == False:\n            MoveRobot(\"w\")\n        else:\n            # when logic gets to this point, it means that all of the available cells around the robot have been searched\n            # if the stack is empty, this means that the maze has been completely searched.\n            # if it isnt empty, it means that the robot is at a dead end.\n            if len(movementStack) == 0:\n                searching = False\n            else:\n                BackTrack()\n        #PrintMazeInfo()\n\n# this method is just used to help me debug, all it does is print out the dictionarry containing the maze info\n# it will output the letters of the direction where there are walls.\ndef PrintMazeInfo():\n    searchedCells = list(mazeInfo.keys())\n    brain.new_line()\n    brain.print(\"NEW INFO\")\n    for i in range (0, len(searchedCells)):\n        outputString = \"\"\n        cellInfo = mazeInfo[searchedCells[i]]\n        if cellInfo.north == True:\n            outputString += \"n\"\n        if cellInfo.east == True:\n            outputString += \"e\"\n        if cellInfo.south == True:\n            outputString += \"s\"\n        if cellInfo.west == True:\n            outputString += \"w\"\n        brain.new_line()\n        brain.print(f\"{searchedCells[i]} : {outputString}\")\n\n# this method will be used by the shortest path algithm to get the cells that neighbor the inputted cell\ndef getNeighbors(cell):\n    neighbors = []\n    brain.print(\"WHAT THE ACTUAL FUCK\")\n    brain.print(f\"TEST : {cell}\")\n    #cellInfo = mazeInfo[f\"{cell[0]}, {cell[1]}\"]\n    cellInfo = mazeInfo[cell]\n\n    # just processing the input string \n    coordinates = cell.split(\", \")\n\n    if not cellInfo.north:\n        neighbors.append([cell[0], cell[1] + 1])\n    if not cellInfo.east:\n        neighbors.append([cell[0] + 1, cell[1]])\n    if not cellInfo.south:\n        neighbors.append([cell[0], cell[1] - 1])\n    if not cellInfo.west:\n        neighbors.append([cell[0] - 1, cell[1]])\n     \n    return neighbors\n\n# this method will handle searching for the shortest path from the entrence to the exit\n# with this method, i have tried to implement dijkstra algorithm.\ndef FindShortestPathToExit():\n    path = []\n    \n    distanceFromStart = {cell : float(\"inf\") for cell in mazeInfo}\n    distanceFromStart[\"0, 0\"] = 0\n\n    previousCells = {}\n    unvisitedCells = list(mazeInfo.keys())\n\n    while len(unvisitedCells) != 0:\n        # this bit of code just gets the cell that is closest to the start and has not been visited. \n        currentCell = min(unvisitedCells, key = lambda cell : distanceFromStart[cell])\n\n        posistionString = f\"{currentCell[0]}, {currentCell[1]}\"\n\n        #this just ends the search when it reaches the end of the maze\n        if currentCell == endPosition:\n            break\n\n        unvisitedCells.remove(currentCell)\n\n        brain.print(f\"TEST BEFORE FUNCTION :  {currentCell}\")\n\n        neighboringCells = getNeighbors(posistionString)\n        for i in range (0, len(neighboringCells)):\n            if neighboringCells[i] in unvisitedCells:\n                currentDistence = distanceFromStart[posistionString] + 1\n                neighborCellPositionString = f\"{neighboringCells[i][0]}, {neighboringCells[i][1]}\"\n                if currentDistance < distanceFromStart[neighborCellPositionString]:\n                    distanceFromStart[neighborCellPositionString] = currentDistence\n                    previousCells[neighborCellPositionString] = posistionString\n\n    brain.print(previousCells)\n    return path\n\ndef when_started1():\n    #map maze - done\n    #find shorest path to end of maze\n    #turn on pen\n    #get to end of maze\n    #fix the bug of the robot moving though the wall between -3, 6 and -4, 6 on that buggy maze\n    #maybe output a visual output of the maze? \n    SearchMaze()\n    shortestPath = FindShortestPathToExit()\n    stop_project()\n    pass\n\nvr_thread(when_started1)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}