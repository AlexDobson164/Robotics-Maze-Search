{"mode":"Text","hardwareTarget":"brain","textContent":"global cellSize\nglobal mazeInfo\nglobal currentPosition\nglobal movementStack\nglobal endPosition\nglobal InvisibleWallFix\n#region VEXcode Generated Robot Configuration\nimport math\nimport random\nimport time\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# just settiing the speed of the robot to the maximum value\ndrivetrain.set_drive_velocity(100, PERCENT)\ndrivetrain.set_turn_velocity(100, PERCENT)\n\n# I found documentation that the maze is 2000mm by 2000mm, the maze is 8 by 8 cells,\n# meaning that each cell is 250mm by 250mm\n# this is the website that i got this information from - https://api.vex.com/vr/home/playgrounds/dynamic_wall_maze.html\ncellSize = 250\n\n# this is a variable that deturmines weather the bugged maze has been fixed or not.\n# i put this on a toggle so that i demonstrait that the robot chooses the shortest path\nInvisibleWallFix = True \n\n# I will be storing the maze info as a dictionary with the key being the coodinates in relation to the origin,\n# this will mean that the robot should be able to work for any size maze. The robot can also quickly check if\n# it has been to a cell before by checking if it exists in the dictionary. The contents of each entry will be a list of\n# the robot can access from that cell\nmazeInfo = {}\n\n# this is just a variable to track where the robot is in relation to the start of the maze.\ncurrentPosition = (0, 0)\nendPosition = ()\n\n# a stack which will store the movements the robot has made, once it has reached a dead end, it can then pop off \n# of this stack until it reaches a point that it can start exploring the maze again\nmovementStack = []\n\n# this method assumes that the entrence is at the bottom of the maze\n# and that the end of the maze is at the top because the robot can leave the maze at these places\ndef SearchCell():\n    global movementStack\n    global endPosition\n    global mazeInfo\n    mazeInfo[currentPosition] = []\n    exploredCells = list(mazeInfo.keys())\n    isEnd = down_eye.detect(RED)\n\n    if isEnd:\n        endPosition = (currentPosition[0], currentPosition[1])\n    \n    # this bit of code gets the last move the robot made so that it wont look behind its self,\n    # i initally set lastMove as \"n\" because it simulates the robot entering the maze.\n    # this also stop a null error from occuring if the stack is empty.\n    lastMove = \"n\"\n    if len(movementStack) != 0:\n        lastMove = movementStack[len(movementStack) - 1]\n    \n    currentX = currentPosition[0]\n    currentY = currentPosition[1]\n\n    # this will add the cell the robot just came from to the list of available cells for the robot to move to from\n    # its current cell\n    # the second check here makes sure that the robot doesnt think that there is a cell south of the start.\n    if lastMove == \"n\" and currentPosition != (0, 0):\n        mazeInfo[currentPosition].append((currentX, currentY - 1))\n    elif lastMove == \"e\":\n        mazeInfo[currentPosition].append((currentX - 1, currentY))\n    elif lastMove == \"s\":\n        mazeInfo[currentPosition].append((currentX, currentY + 1))\n    elif lastMove == \"w\":\n        mazeInfo[currentPosition].append((currentX + 1, currentY))\n    \n    # each direction has 2 checks. the first check makes sure that the direction hasnt been looked at before, \n    # the second check makes sure that the robot doesnt look in the direction that it just came from\n    \n    # checking north\n    # the third check here makes sure that the robot doesnt leave the maze after finding the end\n    if not (currentX, currentY + 1) in exploredCells and lastMove != \"s\" and not isEnd:\n        drivetrain.turn_to_heading(0, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX, currentY + 1))\n    #checking east\n    if not (currentX + 1, currentY) in exploredCells and lastMove != \"w\":\n        drivetrain.turn_to_heading(90, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX + 1, currentY))\n    #checking south\n    #the third check here makes sure that the robot doesnt leave the maze from the entrence\n    if not (currentX, currentY - 1) in exploredCells and lastMove != \"n\" and currentPosition != (0, 0):\n        drivetrain.turn_to_heading(180, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX, currentY - 1))\n    #checking west\n    # I also need to have a check here so that on one of the mazes, \n    # the robot doesnt think there isnt a wall where there is one\n    overide = False\n    if InvisibleWallFix == True:\n        # I can do this with the movement stack as i have checked all of the mazes and\n        # the movement leading to this wall on both sides are unique\n        lastMoveIndex = len(movementStack) - 1\n        # the right side of the wall\n        if currentPosition == (-3, 6):\n            if movementStack[lastMoveIndex] == \"w\" and movementStack[lastMoveIndex - 1] == \"w\" and movementStack[lastMoveIndex - 2] == \"n\":\n                overide = True\n        if currentPosition == (-4, 6):\n            if not (-4, 6) in mazeInfo[(-3, 6)]:\n                overide = True\n\n    if not (currentX - 1, currentY) in exploredCells and lastMove != \"e\" and overide == False:\n        drivetrain.turn_to_heading(270, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX - 1, currentY))\n\n# just a method to move the robot\ndef MoveRobot(direction):\n    global currentPosition\n    global movementStack\n    movementStack.append(direction)\n    if direction == \"n\":\n        drivetrain.turn_to_heading(0, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0], currentPosition[1] + 1)\n    if direction == \"e\":\n        drivetrain.turn_to_heading(90, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0] + 1, currentPosition[1])\n    if direction == \"s\":\n        drivetrain.turn_to_heading(180, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0], currentPosition[1] - 1)\n    if direction == \"w\":\n        drivetrain.turn_to_heading(270, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0] - 1, currentPosition[1])\n\n# this method will make the robot backtrack by looking at the top of the movementStack and doing the oposite and\n# then popping the top of the stack off.\ndef Backtrack():\n    global movementStack\n    topOfStack = movementStack.pop()\n    if topOfStack == \"n\":\n        MoveRobot(\"s\")\n    if topOfStack == \"e\":\n        MoveRobot(\"w\")\n    if topOfStack == \"s\":\n        MoveRobot(\"n\")\n    if topOfStack == \"w\":\n        MoveRobot(\"e\")\n    # i need to pop the top of the stack off again because the moveRobot method adds the last movement to the stack\n    # and i did not feel like it was worth it to make a new movement method without this functionality\n    movementStack.pop()\n\n# this is the method that will handle all of the logic for when the robot is mapping out the maze\ndef SearchMaze():\n    searching = True\n    while searching:\n        searchedCells = list(mazeInfo.keys())\n        if not currentPosition in searchedCells:\n            SearchCell()\n        # bot decides which way to go next by checking which cells around it it has not gone yet\n        # the bot will check up, then left, then down and finally right\n        #currentCellInfo = mazeInfo[currentPosition]\n        possibleCells = mazeInfo[currentPosition]\n        # the first check here makes sure that the cell hasnt been explored yet, the secnd check makes sure that\n        # the robot can move into that cell\n        if not (currentPosition[0], currentPosition[1] + 1) in searchedCells and (currentPosition[0], currentPosition[1] + 1) in possibleCells:\n            MoveRobot(\"n\")\n        elif not (currentPosition[0] + 1, currentPosition[1]) in searchedCells and (currentPosition[0] + 1, currentPosition[1]) in possibleCells:\n            MoveRobot(\"e\")\n        elif not (currentPosition[0], currentPosition[1] - 1) in searchedCells and (currentPosition[0], currentPosition[1] - 1) in possibleCells:\n            MoveRobot(\"s\")\n        elif not (currentPosition[0] - 1, currentPosition[1]) in searchedCells and (currentPosition[0] - 1, currentPosition[1]) in possibleCells:\n            MoveRobot(\"w\")\n        else:\n            # when logic gets to this point, it means that all of the available cells around the robot have been searched\n            # if the stack is empty, this means that the maze has been completely searched.\n            # if it isnt empty, it means that the robot is at a dead end.\n            if len(movementStack) == 0:\n                return\n            else:\n                Backtrack()\n\n# this method is just used to help me debug, all it does is print out the dictionarry containing the maze info\n# it will output the letters of the direction where there are walls.\ndef PrintMazeInfo():\n    searchedCells = list(mazeInfo.keys())\n    brain.new_line()\n    brain.print(\"NEW INFO\")\n    for i in range (0, len(searchedCells)):\n        brain.new_line()\n        brain.print(f\"{searchedCells[i]} : {mazeInfo[searchedCells[i]]}\")\n\n# this method will be used by the shortest path algithm to get the cells that neighbor the inputted cell\ndef GetNeighbors(cell):\n    neighbors = []\n    cellInfo = mazeInfo[cell]\n\n    # just processing the input string \n    coordinates = cell.split(\", \")\n\n    if not cellInfo.north:\n        neighbors.append([cell[0], cell[1] + 1])\n    if not cellInfo.east:\n        neighbors.append([cell[0] + 1, cell[1]])\n    if not cellInfo.south:\n        neighbors.append([cell[0], cell[1] - 1])\n    if not cellInfo.west:\n        neighbors.append([cell[0] - 1, cell[1]])\n     \n    return neighbors\n\n# this method will handle searching for the shortest path from the entrence to the exit\n# with this method, i have tried to implement dijkstra algorithm.\n# i used this video as a guide to implement thiis algorithm - https://www.youtube.com/watch?v=LGiRB_lByh0\ndef FindShortestPathToExit():\n    start = (0, 0)\n    unvisitedCells = {cell : float(\"inf\") for cell in mazeInfo}\n    unvisitedCells[(0, 0)] = 0\n    visitedCells = {}\n    reversePath = {}\n\n    while len(unvisitedCells) != 0:\n        currentCell = min(unvisitedCells, key = unvisitedCells.get)\n        visitedCells[currentCell] = unvisitedCells[currentCell]\n        \n        if currentCell == endPosition:\n            break\n\n        cellNeighbors = mazeInfo[currentCell]\n        for i in range(0, len(cellNeighbors)):\n            if cellNeighbors[i] in visitedCells:\n                continue\n            tempDistance = unvisitedCells[currentCell] + 1\n\n            if tempDistance < unvisitedCells[cellNeighbors[i]]:\n                unvisitedCells[cellNeighbors[i]] = tempDistance\n                reversePath[cellNeighbors[i]] = currentCell\n        \n        unvisitedCells.pop(currentCell)\n\n    # now that we have a list of cells that will lead to the end, i need to reverse engineer it into a list\n    # of directions that will lead to the exit\n    path = []\n    visitedCoordinates = list(reversePath.keys())\n    currentCell = endPosition\n    brain.print(currentCell)\n    while currentCell != (0, 0):\n        previousCell = reversePath[currentCell]\n        #check if the robot needs to move north\n        if currentCell[1] == previousCell[1] + 1:\n            path.append(\"n\")\n        #check if the robot needs to move east\n        elif currentCell[0] == previousCell[0] + 1:\n            path.append(\"e\")\n        #check if the robot needs to move south\n        elif currentCell[1] == previousCell[1] - 1:\n            path.append(\"s\")\n        #check if the robot needs to move west\n        elif currentCell[0] == previousCell[0] - 1:\n            path.append(\"w\")\n        currentCell = previousCell\n    path.reverse()\n    return path\n\ndef FollowPath(path):\n    pen.move(DOWN)\n    for i in range (0, len(path)):\n        MoveRobot(path[i])\n\ndef when_started1():\n    brain.clear()\n    #map maze - done\n    #find shortest path to end of maze - done\n    #turn on pen - done\n    #get to end of maze - done\n    #fix the bug of the robot moving though the wall between -3, 6 and -4, 6 on that buggy maze\n    # output a visual output of the maze? \n    SearchMaze()\n    searchMazeTime = brain.timer_time(SECONDS)\n    brain.print(f\"Time taken to search maze: {searchMazeTime} seconds\")\n    #PrintMazeInfo()\n    shortestPath = FindShortestPathToExit()\n    brain.timer_reset()\n    FollowPath(shortestPath)\n    completeTime = brain.timer_time(SECONDS)\n    brain.new_line()\n    brain.print(f\"Time taken to complete maze: {completeTime} seconds\")\n    brain.new_line()\n    brain.print(f\"Total time taken: {completeTime + searchMazeTime} seconds\")\n    stop_project()\n    pass\n\nvr_thread(when_started1)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}