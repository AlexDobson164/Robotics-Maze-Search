{"mode":"Text","hardwareTarget":"brain","textContent":"global cellSize\nglobal mazeInfo\nglobal currentPosition\nglobal movementStack\nglobal endPosition\n#region VEXcode Generated Robot Configuration\nimport math\nimport random\nimport time\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# just settiing the speed of the robot to the maximum value\ndrivetrain.set_drive_velocity(100, PERCENT)\ndrivetrain.set_turn_velocity(100, PERCENT)\n\n# I found documentation that the maze is 2000mm by 2000mm, the maze is 8 by 8 cells,\n# meaning that each cell is 250mm by 250mm\ncellSize = 250\n\n# I will be storing the maze info as a dictionary with the key being the coodinates in relation to the origin,\n# this will mean that the robot should be able to work for any size maze. The robot can also quickly check if\n# it has been to a cell before by checking if it exists in the dictionary. The contents of each entry will be a list of\n# the robot can access from that cell\nmazeInfo = {}\n\n# this is just a variable to track where the robot is in relation to the start of the maze.\ncurrentPosition = (0, 0)\nendPosition = ()\n\n# a stack which will store the movements the robot has made, once it has reached a dead end, it can then pop off \n# of this stack until it reaches a point that it can start exploring the maze again\nmovementStack = []\n\n\n# this method assumes that the entrence is at the bottom of the maze\n# and that the end of the maze is at the top because the robot can leave the maze at these places\ndef SearchCell():\n    global movementStack\n    global endPosition\n    global mazeInfo\n    mazeInfo[currentPosition] = []\n    exploredCells = list(mazeInfo.keys())\n    isEnd = down_eye.detect(RED)\n\n    if isEnd:\n        endPosition = (currentPosition[0], currentPosition[1])\n        #mazeInfo[currentPosition].north = True\n    \n    # this bit of code gets the last move the robot made so that it wont look behind its self,\n    # i initally set lastMove as \"n\" because it simulates the robot entering the maze.\n    # this also stop a null error from occuring if the stack is empty.\n    lastMove = \"n\"\n    if len(movementStack) != 0:\n        lastMove = movementStack[len(movementStack) - 1]\n    \n    currentX = currentPosition[0]\n    currentY = currentPosition[1]\n\n    # this will add the cell the robot just came from to the list of available cells for the robot to move to from\n    # its current cell\n    # the second check here makes sure that the robot doesnt think that there is a cell south of the start.\n    if lastMove == \"n\" and currentPosition != (0, 0):\n        mazeInfo[currentPosition].append((currentX, currentY - 1))\n    elif lastMove == \"e\":\n        mazeInfo[currentPosition].append((currentX - 1, currentY))\n    elif lastMove == \"s\":\n        mazeInfo[currentPosition].append((currentX, currentY + 1))\n    elif lastMove == \"w\":\n        mazeInfo[currentPosition].append((currentX + 1, currentY))\n    # each direction has 2 checks. the first check makes sure that the direction hasnt been looked at before, \n    # the second check makes sure that the robot doesnt look in the direction that it just came from\n    \n    # checking north\n    # the third check here makes sure that the robot doesnt leave the maze after finding the end\n    if not (currentX, currentY + 1) in exploredCells and lastMove != \"s\" and not isEnd:\n        drivetrain.turn_to_heading(0, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX, currentY + 1))\n    #checking east\n    if not (currentX + 1, currentY) in exploredCells and lastMove != \"w\":\n        drivetrain.turn_to_heading(90, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX + 1, currentY))\n    #checking south\n    #the third check here makes sure that the robot doesnt leave the maze from the entrence\n    if not (currentX, currentY - 1) in exploredCells and lastMove != \"n\" and currentPosition != (0, 0):\n        drivetrain.turn_to_heading(180, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX, currentY - 1))\n    #checking west\n    if not (currentX - 1, currentY) in exploredCells and lastMove != \"e\":\n        drivetrain.turn_to_heading(270, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX - 1, currentY))\n\n# just a method to move the robot\ndef MoveRobot(direction):\n    global currentPosition\n    global movementStack\n    movementStack.append(direction)\n    if direction == \"n\":\n        drivetrain.turn_to_heading(0, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0], currentPosition[1] + 1)\n    if direction == \"e\":\n        drivetrain.turn_to_heading(90, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0] + 1, currentPosition[1])\n    if direction == \"s\":\n        drivetrain.turn_to_heading(180, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0], currentPosition[1] - 1)\n    if direction == \"w\":\n        drivetrain.turn_to_heading(270, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0] - 1, currentPosition[1])\n\n# this method will make the robot backtrack by looking at the top of the movementStack and doing the oposite and\n# then popping the top of the stack off.\ndef Backtrack():\n    global movementStack\n    topOfStack = movementStack.pop()\n    if topOfStack == \"n\":\n        MoveRobot(\"s\")\n    if topOfStack == \"e\":\n        MoveRobot(\"w\")\n    if topOfStack == \"s\":\n        MoveRobot(\"n\")\n    if topOfStack == \"w\":\n        MoveRobot(\"e\")\n    # i need to pop the top of the stack off again because the moveRobot method adds the last movement to the stack\n    # and i did not feel like it was worth it to make a new movement method without this functionality\n    movementStack.pop()\n\n# this is the method that will handle all of the logic for when the robot is mapping out the maze\ndef SearchMaze():\n    searching = True\n    \n    while searching:\n        #brain.new_line()\n        #brain.print(movementStack)\n        \n        searchedCells = list(mazeInfo.keys())\n        if not currentPosition in searchedCells:\n            SearchCell()\n        # bot decides which way to go next by checking which cells around it it has not gone yet\n        # the bot will check up, then left, then down and finally right\n        #currentCellInfo = mazeInfo[currentPosition]\n        possibleCells = mazeInfo[currentPosition]\n        # the first check here makes sure that the cell hasnt been explored yet, the secnd check makes sure that\n        # the robot can move into that cell\n        if not (currentPosition[0], currentPosition[1] + 1) in searchedCells and (currentPosition[0], currentPosition[1] + 1) in possibleCells:\n            MoveRobot(\"n\")\n        elif not (currentPosition[0] + 1, currentPosition[1]) in searchedCells and (currentPosition[0] + 1, currentPosition[1]) in possibleCells:\n            MoveRobot(\"e\")\n        elif not (currentPosition[0], currentPosition[1] - 1) in searchedCells and (currentPosition[0], currentPosition[1] - 1) in possibleCells:\n            MoveRobot(\"s\")\n        elif not (currentPosition[0] - 1, currentPosition[1]) in searchedCells and (currentPosition[0] - 1, currentPosition[1]) in possibleCells:\n            MoveRobot(\"w\")\n        else:\n            # when logic gets to this point, it means that all of the available cells around the robot have been searched\n            # if the stack is empty, this means that the maze has been completely searched.\n            # if it isnt empty, it means that the robot is at a dead end.\n            if len(movementStack) == 0:\n                return\n            else:\n                Backtrack()\n        \n        #PrintMazeInfo()\n\n# this method is just used to help me debug, all it does is print out the dictionarry containing the maze info\n# it will output the letters of the direction where there are walls.\ndef PrintMazeInfo():\n    searchedCells = list(mazeInfo.keys())\n    brain.new_line()\n    brain.print(\"NEW INFO\")\n    for i in range (0, len(searchedCells)):\n        brain.new_line()\n        brain.print(f\"{searchedCells[i]} : {mazeInfo[searchedCells[i]]}\")\n\n# this method will be used by the shortest path algithm to get the cells that neighbor the inputted cell\ndef GetNeighbors(cell):\n    neighbors = []\n    #cellInfo = mazeInfo[f\"{cell[0]}, {cell[1]}\"]\n    cellInfo = mazeInfo[cell]\n\n    # just processing the input string \n    coordinates = cell.split(\", \")\n\n    if not cellInfo.north:\n        neighbors.append([cell[0], cell[1] + 1])\n    if not cellInfo.east:\n        neighbors.append([cell[0] + 1, cell[1]])\n    if not cellInfo.south:\n        neighbors.append([cell[0], cell[1] - 1])\n    if not cellInfo.west:\n        neighbors.append([cell[0] - 1, cell[1]])\n     \n    return neighbors\n\n# this method will handle searching for the shortest path from the entrence to the exit\n# with this method, i have tried to implement dijkstra algorithm.\n# i used this video as a guide to implement thiis algorithm - https://www.youtube.com/watch?v=LGiRB_lByh0\ndef FindShortestPathToExit():\n    start = (0, 0)\n    unvisitedCells = {cell : float(\"inf\") for cell in mazeInfo}\n\n    unvisitedCells[(0, 0)] = 0\n\n    visitedCells = {}\n\n    while len(unvisitedCells) != 0:\n        currentCell = min(unvisitedCells, key = unvisitedCells.get)\n        visitedCells[currentCell] = unvisitedCells[currentCell]\n    #    minNode = min(unvisitedCells, key = unvisitedCells.get)\n    #    visitedCells[minNode] = unvisitedCells[minNode] #unvisitedCells[minNode] # this might need to be changed to 1\n        \n        \n        if currentCell == endPosition:\n            break\n\n        cellNeighbors = mazeInfo[currentCell]\n        for i in range(0, len(cellNeighbors)):\n            if cellNeighbors[i] in visitedCells:\n                continue\n            tempDistance = unvisitedCells[currentCell] + 1\n\n            if tempDistance > unvisitedCells[cellNeighbors[i]]:\n                unvisited[cellNeighbors[i]] = temptempDistance\n        #    if not cellNeighbors[i] in visitedCells:\n        #        tempDistance = visitedCells[minNode] + 1\n        #        brain.print(\"Key : \", cellNeighbors[i])\n        #        brain.new_line()\n        #        brain.print(\"visited : \", visitedCells)\n        #        break\n        #        if tempDistance < visitedCells[cellNeighbors[i]]:\n        #            unvisitedCells[cellNeighbors[i]] = tempDistance\n        unvisitedCells.pop(currentCell)\n        #brain.print(visitedCells)\n        #break\n    brain.print(visitedCells)\n    #    for neighbor in mazeInfo.get(minNode):\n    #        if neighbor in visitedCells:\n    #            continue\n    #        tempDist = unvisitedCells[minNode] + 1\n    #        if tempDist < unvisitedCells[neighbor]:\n    #            unvisitedCells[neighbor] = tempDist\n    #    \n        #this ide needs a 5ms delay between loop iterations \n    #    time.sleep(0.005)\n\n    #brain.print(visitedCells)\n\n    path = []\n    return path\n\ndef when_started1():\n    #map maze - done\n    #find shortest path to end of maze\n    #turn on pen\n    #get to end of maze\n    #fix the bug of the robot moving though the wall between -3, 6 and -4, 6 on that buggy maze\n    #maybe output a visual output of the maze? \n    SearchMaze()\n    #PrintMazeInfo()\n    shortestPath = FindShortestPathToExit()\n    stop_project()\n    pass\n\nvr_thread(when_started1)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}