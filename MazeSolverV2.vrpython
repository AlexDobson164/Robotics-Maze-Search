{"mode":"Text","hardwareTarget":"brain","textContent":"global cellSize\nglobal mazeInfo\nglobal currentPosition\nglobal movementStack\nglobal endPosition\nglobal InvisibleWallFix\n#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# just settiing the speed of the robot to the maximum value\ndrivetrain.set_drive_velocity(100, PERCENT)\ndrivetrain.set_turn_velocity(100, PERCENT)\n\n# I found documentation that the maze is 2000mm by 2000mm, the maze is 8 by 8 cells,\n# meaning that each cell is 250mm by 250mm\n# this is the website that i got this information from - https://api.vex.com/vr/home/playgrounds/dynamic_wall_maze.html\ncellSize = 250\n\n# this is a variable that deturmines weather the bugged maze has been fixed or not.\n# i put this on a toggle so that i demonstrait that the robot chooses the shortest path\nInvisibleWallFix = True \n\n# I will be storing the maze info as a dictionary with the key being the coodinates in relation to the origin,\n# this will mean that the robot should be able to work for any size maze. The robot can also quickly check if\n# it has been to a cell before by checking if it exists in the dictionary. The contents of each entry will be a list of\n# the robot can access from that cell\nmazeInfo = {}\n\n# this is just a variable to track where the robot is in relation to the start of the maze.\ncurrentPosition = (0, 0)\nendPosition = ()\n\n# a stack which will store the movements the robot has made, once it has reached a dead end, it can then pop off \n# of this stack until it reaches a point that it can start exploring the maze again\nmovementStack = []\n\n# this method assumes that the entrence is at the bottom of the maze\n# and that the end of the maze is at the top because the robot can leave the maze at these places\ndef SearchCell():\n    global movementStack\n    global endPosition\n    global mazeInfo\n    mazeInfo[currentPosition] = []\n    exploredCells = list(mazeInfo.keys())\n    isEnd = down_eye.detect(RED)\n\n    if isEnd:\n        endPosition = (currentPosition[0], currentPosition[1])\n    \n    # this bit of code gets the last move the robot made so that it wont look behind its self,\n    # i initally set lastMove as \"n\" because it simulates the robot entering the maze.\n    # this also stop a null error from occuring if the stack is empty.\n    lastMove = \"n\"\n    if len(movementStack) != 0:\n        lastMove = movementStack[len(movementStack) - 1]\n    \n    currentX = currentPosition[0]\n    currentY = currentPosition[1]\n\n    # this will add the cell the robot just came from to the list of available cells for the robot to move to from\n    # its current cell\n    # the second check here makes sure that the robot doesnt think that there is a cell south of the start.\n    if lastMove == \"n\" and currentPosition != (0, 0):\n        mazeInfo[currentPosition].append((currentX, currentY - 1))\n    elif lastMove == \"e\":\n        mazeInfo[currentPosition].append((currentX - 1, currentY))\n    elif lastMove == \"s\":\n        mazeInfo[currentPosition].append((currentX, currentY + 1))\n    elif lastMove == \"w\":\n        mazeInfo[currentPosition].append((currentX + 1, currentY))\n    \n    # each direction has 2 checks. the first check makes sure that the direction hasnt been looked at before, \n    # the second check makes sure that the robot doesnt look in the direction that it just came from\n    \n    # checking north\n    # the third check here makes sure that the robot doesnt leave the maze after finding the end\n    if not (currentX, currentY + 1) in exploredCells and lastMove != \"s\" and not isEnd:\n        drivetrain.turn_to_heading(0, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX, currentY + 1))\n    #checking east\n    if not (currentX + 1, currentY) in exploredCells and lastMove != \"w\":\n        drivetrain.turn_to_heading(90, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX + 1, currentY))\n    #checking south\n    #the third check here makes sure that the robot doesnt leave the maze from the entrence\n    if not (currentX, currentY - 1) in exploredCells and lastMove != \"n\" and currentPosition != (0, 0):\n        drivetrain.turn_to_heading(180, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX, currentY - 1))\n    #checking west\n    # I also need to have a check here so that on one of the mazes, \n    # the robot doesnt think there isnt a wall where there is one\n    overide = False\n    if InvisibleWallFix == True:\n        # I can do this with the movement stack as i have checked all of the mazes and\n        # the movement leading to this wall on both sides are unique\n        lastMoveIndex = len(movementStack) - 1\n        # the right side of the wall\n        if currentPosition == (-3, 6):\n            if movementStack[lastMoveIndex] == \"w\" and movementStack[lastMoveIndex - 1] == \"w\" and movementStack[lastMoveIndex - 2] == \"n\":\n                overide = True\n        if currentPosition == (-4, 6):\n            if (-3,6) in list(mazeInfo.keys()):\n                if not (-4, 6) in mazeInfo[(-3, 6)]:\n                    overide = True\n\n    if not (currentX - 1, currentY) in exploredCells and lastMove != \"e\" and overide == False:\n        drivetrain.turn_to_heading(270, DEGREES)\n        isWallInfront = front_eye.detect(RED)\n        if not isWallInfront:\n            mazeInfo[currentPosition].append((currentX - 1, currentY))\n\n# just a method to move the robot\ndef MoveRobot(direction):\n    global currentPosition\n    global movementStack\n    movementStack.append(direction)\n    if direction == \"n\":\n        drivetrain.turn_to_heading(0, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0], currentPosition[1] + 1)\n    if direction == \"e\":\n        drivetrain.turn_to_heading(90, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0] + 1, currentPosition[1])\n    if direction == \"s\":\n        drivetrain.turn_to_heading(180, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0], currentPosition[1] - 1)\n    if direction == \"w\":\n        drivetrain.turn_to_heading(270, DEGREES)\n        drivetrain.drive_for(FORWARD, cellSize, MM)\n        currentPosition = (currentPosition[0] - 1, currentPosition[1])\n\n# this method will make the robot backtrack by looking at the top of the movementStack and doing the oposite and\n# then popping the top of the stack off.\ndef Backtrack():\n    global movementStack\n    topOfStack = movementStack.pop()\n    if topOfStack == \"n\":\n        MoveRobot(\"s\")\n    if topOfStack == \"e\":\n        MoveRobot(\"w\")\n    if topOfStack == \"s\":\n        MoveRobot(\"n\")\n    if topOfStack == \"w\":\n        MoveRobot(\"e\")\n    # i need to pop the top of the stack off again because the moveRobot method adds the last movement to the stack\n    # and i did not feel like it was worth it to make a new movement method without this functionality\n    movementStack.pop()\n\n# this is the method that will handle all of the logic for when the robot is mapping out the maze\ndef SearchMaze():\n    searching = True\n    while searching:\n        searchedCells = list(mazeInfo.keys())\n        if not currentPosition in searchedCells:\n            SearchCell()\n        # bot decides which way to go next by checking which cells around it it has not gone yet\n        # the bot will check up, then left, then down and finally right\n        #currentCellInfo = mazeInfo[currentPosition]\n        possibleCells = mazeInfo[currentPosition]\n        # the first check here makes sure that the cell hasnt been explored yet, the secnd check makes sure that\n        # the robot can move into that cell\n        if not (currentPosition[0], currentPosition[1] + 1) in searchedCells and (currentPosition[0], currentPosition[1] + 1) in possibleCells:\n            MoveRobot(\"n\")\n        elif not (currentPosition[0] + 1, currentPosition[1]) in searchedCells and (currentPosition[0] + 1, currentPosition[1]) in possibleCells:\n            MoveRobot(\"e\")\n        elif not (currentPosition[0], currentPosition[1] - 1) in searchedCells and (currentPosition[0], currentPosition[1] - 1) in possibleCells:\n            MoveRobot(\"s\")\n        elif not (currentPosition[0] - 1, currentPosition[1]) in searchedCells and (currentPosition[0] - 1, currentPosition[1]) in possibleCells:\n            MoveRobot(\"w\")\n        else:\n            # when logic gets to this point, it means that all of the available cells around the robot have been searched\n            # if the stack is empty, this means that the maze has been completely searched.\n            # if it isnt empty, it means that the robot is at a dead end.\n            if len(movementStack) == 0:\n                return\n            else:\n                Backtrack()\n\n# this method is just used to help me debug, all it does is print out the dictionarry containing the maze info\n# it will output the letters of the direction where there are walls.\ndef PrintMazeInfo():\n    searchedCells = list(mazeInfo.keys())\n    brain.new_line()\n    brain.print(\"NEW INFO\")\n    for i in range (0, len(searchedCells)):\n        brain.new_line()\n        brain.print(f\"{searchedCells[i]} : {mazeInfo[searchedCells[i]]}\")\n\n# this method will handle searching for the shortest path from the entrence to the exit\n# with this method, i have tried to implement dijkstra algorithm.\n# i used this video as a guide to implement thiis algorithm - https://www.youtube.com/watch?v=LGiRB_lByh0\ndef FindShortestPathToExit():\n    start = (0, 0)\n    unvisitedCells = {cell : float(\"inf\") for cell in mazeInfo}\n    unvisitedCells[(0, 0)] = 0\n    visitedCells = {}\n    reversePath = {}\n\n    while len(unvisitedCells) != 0:\n        currentCell = min(unvisitedCells, key = unvisitedCells.get)\n        visitedCells[currentCell] = unvisitedCells[currentCell]\n        \n        if currentCell == endPosition:\n            break\n\n        cellNeighbors = mazeInfo[currentCell]\n        for i in range(0, len(cellNeighbors)):\n            if cellNeighbors[i] in visitedCells:\n                continue\n            tempDistance = unvisitedCells[currentCell] + 1\n\n            if tempDistance < unvisitedCells[cellNeighbors[i]]:\n                unvisitedCells[cellNeighbors[i]] = tempDistance\n                reversePath[cellNeighbors[i]] = currentCell\n        \n        unvisitedCells.pop(currentCell)\n\n    # now that we have a list of cells that will lead to the end, i need to reverse engineer it into a list\n    # of directions that will lead to the exit\n    path = []\n    visitedCoordinates = list(reversePath.keys())\n    currentCell = endPosition\n    while currentCell != (0, 0):\n        previousCell = reversePath[currentCell]\n        #check if the robot needs to move north\n        if currentCell[1] == previousCell[1] + 1:\n            path.append(\"n\")\n        #check if the robot needs to move east\n        elif currentCell[0] == previousCell[0] + 1:\n            path.append(\"e\")\n        #check if the robot needs to move south\n        elif currentCell[1] == previousCell[1] - 1:\n            path.append(\"s\")\n        #check if the robot needs to move west\n        elif currentCell[0] == previousCell[0] - 1:\n            path.append(\"w\")\n        currentCell = previousCell\n    path.reverse()\n    return path\n\ndef FollowPath(path):\n    pen.move(DOWN)\n    for i in range (0, len(path)):\n        MoveRobot(path[i])\n    pen.move(UP)\n\ndef PrintMappedMaze():\n    # this part of the function extracts how big the maze is from the information that the robot gathers\n    topRightCell = max(mazeInfo.keys())\n    bottomLeftCell = min(mazeInfo.keys())\n    mazeWidth = abs(bottomLeftCell[0] - topRightCell[0])\n    mazeHieght = abs(bottomLeftCell[1] - topRightCell[1])\n\n    printList = [[]]\n    printList[0].append(\"+\")\n    for i in range(0, ((mazeWidth + 1) * 2)):\n        printList[0].append(\"-\")\n\n    printList[0].append(\"+\")\n    for i in range (0, mazeHieght):\n        printList.append([])\n        printList.append([])\n        printList[i + 1].append(\"|\")\n        printList[i + 2].append(\"|\")\n        #inside this for loop, it handles generating the rows of the maze\n        for j in range (-1, mazeWidth):\n            currentXCoordinate = bottomLeftCell[0] + j + 1\n            currentYCoordinate = topRightCell[1] - i\n            brain.new_line()\n            brain.print(f\"{currentXCoordinate}, {currentYCoordinate} : {mazeInfo[currentXCoordinate, currentYCoordinate]}\")\n            brain.new_line()\n            brain.print((currentXCoordinate + 1, currentYCoordinate))\n            printList[i + 1].append(\" \")\n\n            if (currentXCoordinate + 1, currentYCoordinate) in mazeInfo[(currentXCoordinate, currentYCoordinate)]:\n                brain.new_line()\n                brain.print(endPosition)\n                if (currentXCoordinate, currentYCoordinate) == endPosition:\n                    printList[i + 1].append(\"E\")\n                elif (currentXCoordinate, currentYCoordinate) == (0, 0):\n                    printList[i + 1].append(\"S\")\n                else:\n                    printList[i + 1].append(\" \") \n            else:\n                printList[i + 1].append(\"|\")\n            # this will handle the print information for between each row of the maze\n            if (currentXCoordinate, currentYCoordinate - 1) in mazeInfo[(currentXCoordinate, currentYCoordinate)]:\n                printList[i + 2].append(\" \") \n            else:\n                printList[i + 2].append(\"-\") \n        break\n\n    brain.new_line()\n    brain.print(printList)\n    #nested loop just prints the list nicely\n    #brain.new_line()\n    #brain.print(len(printList[0]) - 1)\n    #brain.new_line()\n    #brain.print(len(printList))\n    #brain.print(printList)\n    brain.new_line()\n    for i in range (0, len(printList)):\n        for j in range (0, len(printList[i])):\n            brain.print(printList[i][j])\n        brain.new_line()\n\n# this function will return the bot to the start\ndef BackToStart():\n    while len(movementStack) != 0:\n        Backtrack()\n\n# this is based off of this stackoverflow post - https://stackoverflow.com/questions/44872859/how-to-print-a-maze-saved-as-a-dictionary-in-python\ndef stolePrint():\n    mazeInfo=[]\n\n    for r in range(rows_columns(L)[0]):\n        line=[]\n        for cella in celle(L):\n            if cella[0]==r:\n                if L[cella][0]['O']==True:\n                    line.append('|   ')\n\n                if L[cella][0]['O']==False:\n                    line.append('    ')\n\n                if cella[1]==rows_columns(L)[1]-1:\n                    if L[cella][0]['E']==True:\n\n                        line.append('|')\n                    if L[cella][0]['E']==False:\n                        line.append('   ')\n\n\n\n\n        mazeInfo.append(''.join(str(x) for x in line))\n        #cosi ho le righe pari, quelle che contengono le celle.\n        #ora voglio le righe fra le celle\n    mazeInfo2=[]\n    for r in range(rows_columns(L)[0]):\n        line=['+']\n        for cella in celle(L):\n            if cella[0]==r:\n\n                if L[cella][0]['N']==True:\n\n                    line.append('---+')\n                if L[cella][0]['N']==False:\n                    line.append('   +')\n\n\n        mazeInfo2.append(''.join(str(x) for x in line))\n\n    m=''\n    for e in range(0, len(mazeInfo)):\n        m+=mazeInfo2[e]+'\\n'+mazeInfo[e]+'\\n'\n\n    #aggiungo l'ultima line\n    line=[]\n    for cella in celle(L):\n        if cella[0]==rows_columns(L)[0]-1:\n            if L[cella][0]['S']==True:\n                line.append('+---')\n            if L[cella][0]['S']==False:\n                line.append('    ')\n    line.append('+')\n    m+=(''.join(str(x) for x in line))\n    m+='\\n'\n\n    print(m)\n\n#\ndef NewPrint():\n    topRightCell = max(mazeInfo.keys())\n    bottomLeftCell = min(mazeInfo.keys())\n    mazeWidth = abs(bottomLeftCell[0] - topRightCell[0])\n    mazeHieght = abs(bottomLeftCell[1] - topRightCell[1])\n    printList = [[\" \"]*((mazeWidth * 2) + 1)]*((mazeHieght * 2) + 1)\n\n    for x in range(bottomLeftCell[0], topRightCell[0]):\n        for y in range(topRightCell[1], bottomLeftCell[1], -1):\n            cellInfo = mazeInfo[x, y]\n            wallNorth = not (x, y + 1) in cellInfo\n            wallEast = not (x + 1, y) in cellInfo\n            wallSouth = not (x, y - 1) in cellInfo\n            wallWest = not (x - 1, y) in cellInfo\n            brain.print(x)\n            brain.new_line()\n            brain.print(y)\n            brain.new_line()\n            printListX = ((x - bottomLeftCell[0]) * 2) + 1\n            printListY = ((y - topRightCell[1]) * 2) + 1\n            brain.print(printListX)\n            brain.new_line()\n            brain.print(printListY)\n            brain.new_line()\n            printList[printListX - 1][printListY + 1] = \"#\"\n            printList[printListX + 1][printListY + 1] = \"#\"\n            printList[printListX - 1][printListY - 1] = \"#\"\n            printList[printListX + 1][printListY - 1] = \"#\"\n\n            if not wallNorth:\n                printList[printListX][printListY + 1] = \" \"\n            else:\n                printList[printListX][printListY + 1] = \"#\"\n            \n            if not wallEast:\n                printList[printListX + 1][printListY] = \" \"\n            else:\n                printList[printListX + 1][printListY] = \"#\"\n\n            if not wallSouth:\n                printList[printListX][printListY - 1] = \" \"\n            else:\n                printList[printListX][printListY - 1] = \"#\"\n\n            if not wallWest:\n                printList[printListX - 1][printListY] = \" \"\n            else:\n                printList[printListX - 1][printListY] = \"#\"\n            break\n        break\n    \n\n    \n    for i in range (0, len(printList)):\n        for j in range (0, len(printList[i])):\n            brain.print(printList[i][j])\n        brain.new_line()            \n\n    \n\n\ndef when_started1():\n    brain.clear()\n    #fix the bug of the robot moving though the wall between -3, 6 and -4, 6 on that buggy maze\n    # output a visual output of the maze? #\n    SearchMaze()\n    NewPrint()\n    #PrintMappedMaze()\n    searchMazeTime = brain.timer_time(SECONDS)\n    brain.print(f\"Time taken to search maze: {searchMazeTime} seconds\")\n    shortestPath = FindShortestPathToExit()\n    brain.timer_reset()\n    FollowPath(shortestPath)\n    completeTime = brain.timer_time(SECONDS)\n    brain.new_line()\n    brain.print(f\"Time taken to complete maze: {completeTime} seconds\")\n    brain.new_line()\n    brain.print(f\"Total time taken: {completeTime + searchMazeTime} seconds\")\n    \n    BackToStart()\n    stop_project()\n    pass\n\nvr_thread(when_started1)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}